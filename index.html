<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Sunny and the Kids Go to Wyoming</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #0b0b0b; }
    body {
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    #wrap { width: min(100vw, 480px); height: 100%; position: relative; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; background: #cfe9ff; }

    /* More see-through HUD so it doesn't block gameplay */
    .hud {
      position: absolute;
      top: 10px; left: 10px; right: 10px;
      color: rgba(255,255,255,.92);
      font: 13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      padding: 8px 10px;
      border-radius: 14px;
      white-space: pre-line;
      pointer-events: none;
      backdrop-filter: blur(6px);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div class="hud" id="hud">Loading...</div>
    <!-- iPhone-ish internal resolution; scaled by CSS -->
    <canvas id="c" width="390" height="844"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const hud = document.getElementById("hud");

  const W = canvas.width, H = canvas.height;

  // ---------- Helpers ----------
  const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
  const dist = (ax,ay,bx,by) => Math.hypot(ax-bx, ay-by);

  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    };
  }

  // ---------- Characters ----------
  // Sunny: feminine look (beige dress, straight black hair, soft features)
  const sunny = {
    x: 85, y: H-185, speed: 215,
    name: "Sunny", r: 18,
    style: { skin:"#f2d6c9", hair:"#111", outfit:"#d8c6a3" } // beige
  };

  // Dad: bald, black beard, all black
  const dad = {
    x: 48, y: H-150,
    name: "Dad", r: 17,
    style: { skin:"#f2d6c9", beard:"#111", outfit:"#111" }
  };

  // Babies
  const enoch = {
    x: 120, y: H-135,
    name: "Enoch", r: 12,
    style: { skin:"#f2d6c9", hair:"#2a1c12", outfit:"#93c5fd" }
  };

  const elizabeth = {
    x: 150, y: H-155,
    name: "Elizabeth", r: 12,
    style: { skin:"#f2d6c9", hair:"#2a1c12", outfit:"#f9a8d4" }
  };

  // ---------- Collectibles (no emojis) ----------
  // Each item has a type so we can draw it as a cookie / coffee / chocolate / pinecone etc.
  const items = [
    { id:"cookies",   type:"cookie",   label:"Cookies",       msg:"Fresh cookies. Everyone gets one.",                  x:285, y:H-270, r:13, taken:false },
    { id:"coffee",    type:"coffee",   label:"Warm coffee",   msg:"A warm cup makes the cold feel cozy.",              x:225, y:235,    r:13, taken:false },
    { id:"chocolate", type:"choco",    label:"Chocolates",    msg:"A little chocolate for the road.",                  x:310, y:325,    r:13, taken:false },
    { id:"pinecone",  type:"pinecone", label:"Pinecone",      msg:"A perfect pinecone for the memory box.",           x:80,  y:270,    r:13, taken:false },
    { id:"postcard",  type:"postcard", label:"Postcard",      msg:"A postcard to remember this trip.",                 x:70,  y:410,    r:13, taken:false },
    { id:"blanket",   type:"blanket",  label:"Soft blanket",  msg:"A soft blanket for the babies.",                   x:235, y:455,    r:13, taken:false },
  ];

  // Goal spot (no emojis)
  const goal = { x:330, y:120, r:18, label:"Family photo spot" };

  // ---------- Background ----------
  const mountains = [
    {x: -20, y: 430, w: 200, h: 170},
    {x: 110, y: 400, w: 240, h: 200},
    {x: 250, y: 445, w: 220, h: 160}
  ];

  // little house in the background
  const house = { x: 280, y: 505, w: 72, h: 52 };

  // ---------- Input ----------
  const keys = new Set();
  addEventListener("keydown", e => keys.add(e.key.toLowerCase()));
  addEventListener("keyup",   e => keys.delete(e.key.toLowerCase()));

  let drag = null;
  canvas.addEventListener("pointerdown", (e) => {
    const rect = canvas.getBoundingClientRect();
    drag = {
      sx: (e.clientX-rect.left) * (W/rect.width),
      sy: (e.clientY-rect.top)  * (H/rect.height),
      x: null, y: null
    };
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!drag) return;
    const rect = canvas.getBoundingClientRect();
    drag.x = (e.clientX-rect.left) * (W/rect.width);
    drag.y = (e.clientY-rect.top)  * (H/rect.height);
  });
  canvas.addEventListener("pointerup", () => drag = null);
  canvas.addEventListener("pointercancel", () => drag = null);

  // ---------- State ----------
  let collected = [];
  let popup = null; // {text, t}
  function showPopup(text) { popup = { text, t: 3.6 }; }

  function follow(follower, target, dt, followSpeed=190) {
    const dx = target.x - follower.x;
    const dy = target.y - follower.y;
    const d = Math.hypot(dx,dy);
    if (d < 0.01) return;
    const desired = 54;
    if (d > desired) {
      follower.x += (dx/d) * followSpeed * dt;
      follower.y += (dy/d) * followSpeed * dt;
    }
    follower.x = clamp(follower.x, follower.r, W-follower.r);
    follower.y = clamp(follower.y, follower.r, H-follower.r);
  }

  function babyBob(baby, anchor, dt, phaseOffset) {
    baby._t = (baby._t || 0) + dt;
    const ox = Math.cos(baby._t*1.4 + phaseOffset) * 14;
    const oy = Math.sin(baby._t*1.7 + phaseOffset) * 10;
    baby.x = clamp(anchor.x + 55 + ox + (phaseOffset > 0 ? 22 : 0), baby.r, W-baby.r);
    baby.y = clamp(anchor.y + 45 + oy + (phaseOffset > 0 ? -10 : 12), baby.r, H-baby.r);
  }

  function tryCollect(who) {
    for (const it of items) {
      if (it.taken) continue;
      if (dist(who.x, who.y, it.x, it.y) < who.r + it.r + 7) {
        it.taken = true;
        collected.push(it.label);
        showPopup(it.msg);
      }
    }
  }

  // ---------- Drawing ----------
  function drawMountains() {
    ctx.fillStyle = "#97afc6";
    for (const m of mountains) {
      ctx.beginPath();
      ctx.moveTo(m.x, m.y+m.h);
      ctx.lineTo(m.x+m.w*0.5, m.y);
      ctx.lineTo(m.x+m.w, m.y+m.h);
      ctx.closePath();
      ctx.fill();

      // snow cap
      ctx.fillStyle = "rgba(255,255,255,.78)";
      ctx.beginPath();
      ctx.moveTo(m.x+m.w*0.5, m.y);
      ctx.lineTo(m.x+m.w*0.42, m.y+m.h*0.20);
      ctx.lineTo(m.x+m.w*0.58, m.y+m.h*0.20);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#97afc6";
    }
  }

  function drawHouse() {
    const {x,y,w,h} = house;

    // base
    ctx.fillStyle = "rgba(120, 90, 70, .55)";
    ctx.roundRect(x, y, w, h, 8);
    ctx.fill();

    // roof
    ctx.fillStyle = "rgba(80, 60, 55, .65)";
    ctx.beginPath();
    ctx.moveTo(x-6, y+8);
    ctx.lineTo(x+w/2, y-28);
    ctx.lineTo(x+w+6, y+8);
    ctx.closePath();
    ctx.fill();

    // door
    ctx.fillStyle = "rgba(30, 30, 30, .55)";
    ctx.roundRect(x+w*0.42, y+h*0.46, w*0.16, h*0.54, 6);
    ctx.fill();

    // windows
    ctx.fillStyle = "rgba(220, 235, 255, .45)";
    ctx.roundRect(x+w*0.14, y+h*0.28, w*0.22, h*0.20, 4); ctx.fill();
    ctx.roundRect(x+w*0.64, y+h*0.28, w*0.22, h*0.20, 4); ctx.fill();

    // chimney
    ctx.fillStyle = "rgba(90, 70, 60, .65)";
    ctx.fillRect(x+w*0.70, y-22, 10, 18);
  }

  function drawCollectible(it) {
    const x = it.x, y = it.y;

    // subtle shadow
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.beginPath(); ctx.ellipse(x, y+14, it.r+6, 7, 0, 0, Math.PI*2); ctx.fill();

    if (it.type === "cookie") {
      // cookie
      ctx.fillStyle = "#c59a6c";
      ctx.beginPath(); ctx.arc(x, y, it.r, 0, Math.PI*2); ctx.fill();
      // chips
      ctx.fillStyle = "rgba(70,45,30,.75)";
      for (let i=0;i<6;i++){
        const a = i*1.05 + 0.4;
        ctx.beginPath();
        ctx.arc(x + Math.cos(a)*6, y + Math.sin(a)*5, 2.1, 0, Math.PI*2);
        ctx.fill();
      }
      // highlight ring
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(x, y, it.r-2, 0, Math.PI*2); ctx.stroke();
      ctx.lineWidth = 1;
    }

    if (it.type === "coffee") {
      // cup
      ctx.fillStyle = "rgba(245,245,245,.85)";
      ctx.roundRect(x-12, y-8, 24, 18, 6); ctx.fill();
      // handle
      ctx.strokeStyle = "rgba(245,245,245,.85)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x+13, y, 6, -Math.PI/2, Math.PI/2);
      ctx.stroke();
      ctx.lineWidth = 1;
      // coffee surface
      ctx.fillStyle = "rgba(80,50,30,.85)";
      ctx.beginPath(); ctx.ellipse(x, y-4, 9, 3.5, 0, 0, Math.PI*2); ctx.fill();
      // steam
      ctx.strokeStyle = "rgba(255,255,255,.35)";
      ctx.lineWidth = 2;
      for (let i=0;i<2;i++){
        const sx = x - 6 + i*12;
        ctx.beginPath();
        ctx.moveTo(sx, y-18);
        ctx.quadraticCurveTo(sx+5, y-28, sx, y-36);
        ctx.stroke();
      }
      ctx.lineWidth = 1;
    }

    if (it.type === "choco") {
      // chocolate box
      ctx.fillStyle = "rgba(95,55,35,.85)";
      ctx.roundRect(x-13, y-11, 26, 22, 6); ctx.fill();
      // squares
      ctx.fillStyle = "rgba(70,40,25,.55)";
      for (let r=0;r<2;r++){
        for (let c=0;c<2;c++){
          ctx.roundRect(x-11 + c*13, y-9 + r*11, 12, 10, 3);
          ctx.fill();
        }
      }
      // ribbon
      ctx.fillStyle = "rgba(240, 220, 180, .60)";
      ctx.fillRect(x-2, y-11, 4, 22);
      ctx.fillRect(x-13, y-1, 26, 4);
    }

    if (it.type === "pinecone") {
      // pinecone body
      ctx.fillStyle = "rgba(105,70,45,.9)";
      ctx.beginPath(); ctx.ellipse(x, y+2, 9, 13, 0, 0, Math.PI*2); ctx.fill();
      // scales
      ctx.strokeStyle = "rgba(60,40,25,.55)";
      ctx.lineWidth = 2;
      for (let i=-2;i<=2;i++){
        ctx.beginPath();
        ctx.arc(x, y + i*5, 8 - Math.abs(i), 0, Math.PI);
        ctx.stroke();
      }
      ctx.lineWidth = 1;
      // stem
      ctx.fillStyle = "rgba(75,50,35,.9)";
      ctx.roundRect(x-2, y-14, 4, 6, 2); ctx.fill();
    }

    if (it.type === "postcard") {
      // postcard
      ctx.fillStyle = "rgba(250,250,250,.9)";
      ctx.roundRect(x-14, y-10, 28, 20, 4); ctx.fill();
      // line + stamp
      ctx.strokeStyle = "rgba(40,40,40,.25)";
      ctx.beginPath(); ctx.moveTo(x-2, y-8); ctx.lineTo(x-2, y+8); ctx.stroke();
      ctx.strokeRect(x+6, y-8, 6, 6);
      // tiny address lines
      ctx.beginPath(); ctx.moveTo(x+2, y+1); ctx.lineTo(x+12, y+1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+2, y+6); ctx.lineTo(x+12, y+6); ctx.stroke();
    }

    if (it.type === "blanket") {
      // folded blanket
      ctx.fillStyle = "rgba(180, 210, 255, .85)";
      ctx.roundRect(x-14, y-10, 28, 20, 6); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,.35)";
      ctx.fillRect(x-14, y-2, 28, 3);
      ctx.fillStyle = "rgba(60,60,60,.20)";
      ctx.beginPath(); ctx.moveTo(x-14, y-10); ctx.lineTo(x-2, y-10); ctx.lineTo(x-14, y+2); ctx.closePath(); ctx.fill();
    }
  }

  function drawCharacter(ch, type) {
    const x = ch.x, y = ch.y;

    // shadow
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.beginPath(); ctx.ellipse(x, y + ch.r + 10, ch.r+6, 8, 0, 0, Math.PI*2); ctx.fill();

    // body
    if (type === "sunny") {
      // dress silhouette
      ctx.fillStyle = ch.style.outfit;
      ctx.beginPath();
      ctx.moveTo(x, y-4);
      ctx.quadraticCurveTo(x-18, y+8, x-22, y+36);
      ctx.lineTo(x+22, y+36);
      ctx.quadraticCurveTo(x+18, y+8, x, y-4);
      ctx.closePath();
      ctx.fill();

      // waist band
      ctx.fillStyle = "rgba(255,255,255,.22)";
      ctx.roundRect(x-18, y+12, 36, 6, 3);
      ctx.fill();
    } else {
      // simple body
      ctx.fillStyle = ch.style.outfit;
      const bw = ch.r*2 + 6, bh = ch.r*2 + 10;
      ctx.roundRect(x-bw/2, y-bh/2+10, bw, bh, 12);
      ctx.fill();
    }

    // head
    ctx.fillStyle = ch.style.skin;
    ctx.beginPath(); ctx.arc(x, y - ch.r*0.95, ch.r, 0, Math.PI*2); ctx.fill();

    // hair / beard
    if (type === "sunny") {
      ctx.fillStyle = ch.style.hair;
      // straight hair cap
      ctx.beginPath();
      ctx.arc(x, y - ch.r*1.18, ch.r*0.98, Math.PI, Math.PI*2);
      ctx.fill();
      // side hair panels
      ctx.roundRect(x - ch.r*1.10, y - ch.r*1.02, ch.r*0.58, ch.r*1.75, 10); ctx.fill();
      ctx.roundRect(x + ch.r*0.52, y - ch.r*1.02, ch.r*0.58, ch.r*1.75, 10); ctx.fill();

      // little hair shine
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x-5, y - ch.r*1.65);
      ctx.quadraticCurveTo(x-15, y - ch.r*1.05, x-6, y - ch.r*0.45);
      ctx.stroke();
      ctx.lineWidth = 1;
    } else if (type === "dad") {
      ctx.fillStyle = ch.style.beard;
      ctx.beginPath(); ctx.arc(x, y - ch.r*0.55, ch.r*0.95, 0, Math.PI); ctx.fill();
      ctx.fillRect(x - ch.r*0.55, y - ch.r*1.05, ch.r*1.1, 3);
    } else {
      // baby hair
      ctx.fillStyle = ch.style.hair;
      ctx.beginPath(); ctx.arc(x, y - ch.r*1.35, ch.r*0.7, Math.PI, Math.PI*2); ctx.fill();
    }

    // eyes (bigger for babies)
    ctx.fillStyle = "#111";
    const isBaby = (type === "baby");
    const eye = isBaby ? 2.2 : 1.8;
    const eyey = y - ch.r*1.05;

    ctx.beginPath(); ctx.arc(x - ch.r*0.35, eyey, eye, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + ch.r*0.35, eyey, eye, 0, Math.PI*2); ctx.fill();

    if (type === "sunny") {
      // eyelashes
      ctx.strokeStyle = "rgba(0,0,0,.55)";
      ctx.lineWidth = 1.5;
      for (const s of [-1, 1]) {
        const ex = x + s*ch.r*0.35;
        ctx.beginPath(); ctx.moveTo(ex-3, eyey-5); ctx.lineTo(ex, eyey-7); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ex,   eyey-5); ctx.lineTo(ex+3, eyey-7); ctx.stroke();
      }
      ctx.lineWidth = 1;

      // rosy cheeks
      ctx.fillStyle = "rgba(255,120,140,.25)";
      ctx.beginPath(); ctx.arc(x - ch.r*0.55, eyey+10, 4.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + ch.r*0.55, eyey+10, 4.2, 0, Math.PI*2); ctx.fill();

      // small smile
      ctx.strokeStyle = "rgba(0,0,0,.45)";
      ctx.beginPath();
      ctx.arc(x, eyey+13, 6, 0.15*Math.PI, 0.85*Math.PI);
      ctx.stroke();
    }

    // name label (small)
    ctx.fillStyle = "rgba(0,0,0,.50)";
    ctx.font = "12px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(ch.name, x, y - ch.r*2.35);
    ctx.textAlign = "start";
  }

  function drawPopup() {
    if (!popup) return;
    const lines = String(popup.text).split("\n");
    const pad = 12;
    ctx.font = "16px system-ui";
    const maxW = W - 24;
    const lineH = 22;
    const boxH = pad*2 + lines.length*lineH;
    const bx = 12;
    const by = 84;

    ctx.fillStyle = "rgba(0,0,0,.42)";
    ctx.roundRect(bx, by, maxW, boxH, 14);
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.strokeRect(bx+1, by+1, maxW-2, boxH-2);

    ctx.fillStyle = "rgba(255,255,255,.92)";
    let ty = by + pad + 16;
    for (const ln of lines) {
      ctx.fillText(ln, bx + pad, ty);
      ty += lineH;
    }
  }

  function draw(allTaken) {
    ctx.clearRect(0,0,W,H);

    // sky
    ctx.fillStyle = "#cfe9ff";
    ctx.fillRect(0,0,W,H);

    // sun
    ctx.fillStyle = "#ffd36a";
    ctx.beginPath(); ctx.arc(70, 85, 42, 0, Math.PI*2); ctx.fill();

    // mountains
    drawMountains();

    // ground
    ctx.fillStyle = "#e8f7d5";
    ctx.fillRect(0, 520, W, H-520);

    // little house (back)
    drawHouse();

    // path
    ctx.fillStyle = "rgba(120,90,60,.16)";
    ctx.beginPath();
    ctx.moveTo(0, H-230);
    ctx.quadraticCurveTo(W*0.35, H-345, W, H-275);
    ctx.lineTo(W, H-190);
    ctx.quadraticCurveTo(W*0.35, H-275, 0, H-160);
    ctx.closePath();
    ctx.fill();

    // collectibles
    for (const it of items) {
      if (it.taken) continue;
      drawCollectible(it);
    }

    // goal marker (subtle, no emoji)
    ctx.fillStyle = allTaken ? "rgba(56,211,159,.85)" : "rgba(60,60,60,.30)";
    ctx.beginPath(); ctx.arc(goal.x, goal.y, goal.r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.font = "12px system-ui";
    ctx.textAlign = "center";
    ctx.fillText("PHOTO", goal.x, goal.y+4);
    ctx.textAlign = "start";

    // characters
    drawCharacter(enoch, "baby");
    drawCharacter(elizabeth, "baby");
    drawCharacter(dad, "dad");
    drawCharacter(sunny, "sunny");

    // popup
    drawPopup();
  }

  function updateHUD(allTaken) {
    const remaining = items.filter(i=>!i.taken).length;
    const controls = "Move Sunny: drag on screen (or WASD/arrow keys)";
    const goalText = allTaken
      ? "All memories collected. Walk to the photo spot."
      : `Memories collected: ${items.length-remaining}/${items.length}`;
    hud.textContent = `${controls}\n${goalText}`;
  }

  // ---------- Loop ----------
  let last = performance.now();
  function loop(now) {
    const dt = (now - last) / 1000; last = now;

    // Move Sunny
    let vx = 0, vy = 0;
    if (keys.has("arrowleft") || keys.has("a")) vx -= 1;
    if (keys.has("arrowright")|| keys.has("d")) vx += 1;
    if (keys.has("arrowup")   || keys.has("w")) vy -= 1;
    if (keys.has("arrowdown") || keys.has("s")) vy += 1;

    if (drag && drag.x != null) {
      const dx = drag.x - drag.sx;
      const dy = drag.y - drag.sy;
      const l = Math.hypot(dx,dy) || 1;
      vx = dx/l; vy = dy/l;
      if (Math.hypot(dx,dy) < 16) { vx = 0; vy = 0; }
    }

    const l2 = Math.hypot(vx,vy) || 1;
    vx/=l2; vy/=l2;

    sunny.x += vx * sunny.speed * dt;
    sunny.y += vy * sunny.speed * dt;
    sunny.x = clamp(sunny.x, sunny.r, W-sunny.r);
    sunny.y = clamp(sunny.y, sunny.r, H-sunny.r);

    // Family behavior
    follow(dad, sunny, dt, 200);
    babyBob(enoch, sunny, dt, -0.7);
    babyBob(elizabeth, sunny, dt, 0.9);

    // Collecting
    tryCollect(sunny);
    tryCollect(dad);

    const allTaken = items.every(i=>i.taken);

    // Goal
    if (allTaken && dist(sunny.x,sunny.y,goal.x,goal.y) < sunny.r + goal.r + 8) {
      showPopup("Family photo time.\n\nTo my wife: thanks for being the heart of every adventure.");
    }

    if (popup) {
      popup.t -= dt;
      if (popup.t <= 0) popup = null;
    }

    draw(allTaken);
    updateHUD(allTaken);
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
